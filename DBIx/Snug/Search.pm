package DBIx::Snug::Search;

###########################################################################
#                                                                         #
# DBIx::Snug::Search                                                      #
# Copyright 2006-2010, Albert P. Tobey <tobert@gmail.com>                 #
#                                                                         #
###########################################################################

use strict;
use warnings;
use Carp;
use Scalar::Util qw(blessed looks_like_number);
use Data::Dumper;

=head1 NAME

DBIx::Snug::Search

=head1 DESCRIPTION

This is a sub-module of DBIx::Snug that makes creating searches across multiple
tables pretty easy and does it in a fairly perlish way.    The performance on databases
supporting MINUS/INTERSECT well should be as good as hand-written SQL.   For others,
it might be necessary to point at denormalized tables or optimized views, in which
cases this module doesn't have a lot to offer other than writing simple queries for you.

=head1 SYNOPSIS

=head1 METHODS

=over 4

=item new()

Create a new object.  The argument should be the list of keys to search for (not on).

When the SELECT queries are generated, these will be selected.   Then the queries are put together using INTERSECT on those keys.

 my $search = DBIx::Snug::Search->new(qw(node_id));

=cut

sub new {
    my( $class, @on ) = @_;
    return bless { on => \@on, subqueries => [] }, $class;
}

=item on()

Returns the list of keys that are being searched for in an arrayref.   See new().

 my @keys = $search->on;

 my $sq = "SELECT " . join( ',', @{$search->on} ) ...

=cut

sub on { shift->{on} }

=item where()

Create a subquery with a custom WHERE clause.

 my $w = "foo = ? AND bar = ?";
 $search->where( 'foo_table' => $w => [ $foo, $bar ] );

=cut

sub where {
    my( $self, $table, $clause, $values ) = @_;

    if ( defined $values && ref $values ne 'ARRAY' ) {
        $values = [ $values ];
    }

    my $sq = 'SELECT '.join( ', ', @{$self->on} ).' FROM '.$table.' WHERE ';
    $sq .= $clause;

    $self->select( $sq, $values );
}

=item simple()

Avoid SQL altogether.

 $search->simple( 'foo_table', 'foo_name', $foo );

=cut

sub simple {
    my( $self, $table, $fields, $values ) = @_;
    my $sq = $self->__simple( $table, $fields, $values );
    $self->where( $table, $sq, $values );
}

sub __simple {
    my( $self, $table, $fields, $values ) = @_;

    if ( defined $fields && ref $fields ne 'ARRAY' ) {
        $fields = [ $fields ];
    }

    return join( ' AND ', map { "$_ = ?" } @$fields );
}

=item like(), regex(), rlike()

Build a LIKE match using bind variables.   regex() and rlike() are for the equivalent
MySQL functions.   They allow you to use POSIX regular expression matching.

For now, Oracle is probably not going to allow the SQL generated here as either
OCI or DBD::Oracle escapes the % or _ match characters within bind variables so they
need to be moved out into SQL string concatenations, i.e. q{ % || ? || % }.

Multiple columns in one call will be AND'ed together (foo LIKE bar AND bar LIKE baz).

 $search->like( $table, [ 'foo_name', 'foo_desc' ], [ "\%$name", "\%$desc\%" ] );
 $search->regex( $table, 'foo_name', '^arg[a-z]+' );

=cut

sub like  { shift->_like( 'LIKE',  @_ ) } # ANSI (not Oracle)
sub regex { shift->_like( 'REGEX', @_ ) } # MySQL
sub rlike { shift->_like( 'RLIKE', @_ ) } # MySQL
# generic implementation for like/regex/rlike
sub _like {
    my( $self, $match_op, $table, $fields, $values ) = @_;
    my $sql = $self->__like( $match_op, $table, $fields, $values );
    $self->where( $table, $sql, $values );
}
sub __like {
    my( $self, $match_op, $table, $fields, $values ) = @_;

    unless ( ref $fields eq 'ARRAY' ) {
        $fields = [ $fields ];
    }
    # this will appear again when we call into $self->where(), but it's needed
    # here to check that the number of fields/values are balanced
    unless ( ref $values eq 'ARRAY' ) {
        $values = [ $values ];
    }

    confess "BUG: Unbalanced number of fields and values passed to where_like()."
        unless ( @$fields == @$values );

    my @stmts;
    for ( my $i=0; $i<@$fields; $i++ ) {
        push @stmts, "$fields->[$i] $match_op ?";
    }

    return join( ' AND ', @stmts );
}

=item select()

Lets you pass a complete SELECT statement through to be added to the internal
list of subqueries.    The query generated by the query() method will be invalid
if your selection does not match what was specified to new().

 $search->select( "SELECT foo_id,bar_id FROM foo_bar WHERE col1 = ?", $col1_val );

=cut

sub select {
    my( $self, $query ) = @_;

    push @{$self->{subqueries}}, $query;

    if ( @_ == 3 ) {
        my $values = $_[2];
        unless ( ref $values eq 'ARRAY' ) {
            $values = [ $values ];
        }
        push @{$self->{bindvals}}, @$values;
    }

    return $query;
}

=item order_by()

Specify which column(s) to order by.  This must be one of the columns passed to
new().

 $search->order_by( 'foo_id' => 'desc' );

=cut

sub order_by {
    my( $self, $column, $direction ) = @_;
    if ( ref $column eq 'ARRAY' ) {
        $column = join( ',', @$column );
    }
    $self->{order_by} = $column;

    if ( $direction && $direction =~ /^(asc|desc)/i ) {
        $self->{order_by} .= ' '. uc($1);
    }
}

=item limit()

Set a limit on how many rows to return.   In Oracle, this means the
query will get wrapped as a subquery and use rownum (yes, I know it's evil).

In MySQL it simply uses "LIMIT".

 $search->limit( 10 );

=cut

sub limit {
    my( $self, $limit ) = @_;
    if ( looks_like_number($limit) ) {
        $self->{limit} = $limit;
    }
}

=item query()

Builds and returns the full query string.

 my $q = $search->query;

=cut

sub query {
    my $self = shift;

    my $sq_count = scalar @{$self->{subqueries}};
    my $query;

    if ( $sq_count > 1 ) {
        # most reasonable databases support INTERSECT
        $query = join( "\nINTERSECT\n",
            map { "   ( $_ )" } @{ $self->{subqueries} }
        );
    }
    else {
        $query = $self->{subqueries}[0];
    }

    # MySQL is lame. No INTERSECT or MINUS capability so it must be hacked.
    # The performance for this might really stink on large datasets. Also,
    # there's potential for false-positives and false-negatives if the selected
    # key has duplicate rows in a table.    This should be extremely rare when
    # using DBIx::Snug since it really pushes strong primary keys.
    if ( $self->database eq 'mysql' && $sq_count > 1 ) {
        $query = 'SELECT * FROM (' . $/ .
            join( "\nUNION ALL\n", @{$self->{subqueries}} ) . $/ .
            ') AS intersection ' . $/ .
            'GROUP BY ' . join(',', map { 'intersection.'.$_ } @{$self->on}) .
            ' HAVING COUNT(*) = ' . $sq_count;
    }

    # Oracle is just as lame for not having LIMIT
    if ( $self->database eq 'oracle' ) {
        if ( $self->{order_by} || $self->{limit} ) {
            $query = "SELECT * FROM (\n" . $query . "\n)";
        }
        # Yes, I know rownum is evil ...
        if ( $self->{limit} && looks_like_number($self->{limit}) ) {
            $query .= " WHERE rownum <= ". $self->{limit};
        }
    }
    elsif ( grep { $_ eq $self->database } qw(mysql sqlite) ) {
        if ( $self->{limit} && looks_like_number($self->{limit}) ) {
            $query .= " LIMIT ". $self->{limit};
        }
    }

    if ( $self->{order_by} && ref $self->{order_by} eq 'ARRAY' ) {
        confess "Invalid sort order \"$self->{order_by}[1]\""
            unless ( $self->{order_by}[1] =~ /^(?:desc|asc)/i );

        $query .= ' ORDER BY '. $self->{order_by}[0] .' '. $self->{order_by}[1];
    }
    elsif ( $self->{order_by} ) {
        $query .= ' ORDER BY '. $self->{order_by};
    }

    return $query;
}

=item bindvals()

Returns all of the bindvals in an arrayref.

 my $vals = $search->bindvals;

=cut

sub bindvals {
    my $self = shift;
    return $self->{bindvals};
}

=item sth()

Returns a prepared and executed statement handle ready to be used
as an iterator.

 my $sth = $search->sth;
 while ( my $href = $sth->fetchrow_hashref ) {
    ...
 }

=cut

sub sth {
    my( $self, $dbh ) = @_;
    my( $sth, $query );

    eval {
        $query = $self->query;
        local $dbh->{FetchHashKeyName} = 'NAME_lc';
        $sth = $dbh->prepare( $query );
        $sth->execute( @{ $self->{bindvals} } );
    };

    if ( $@ || $dbh->err ) {
        my $cnt = 1;
        warn "Query: $query\n\nArguments:\n\t".join("\n\t", map { $cnt++.' => '.$_ } @{$self->{bindvals}})."\n\n";
        confess $@;
    }

    return $sth;
}

=item execute()

Does the complete search returning the results in an array
of hashrefs.

 my @results = $search->execute( $dbh );

=cut

sub execute {
    my( $self, $dbh ) = @_;

    my $sth = $self->sth( $dbh );
    my @results;
    while ( my $href = $sth->fetchrow_hashref ) {
        push @results, $href;
    }
    return @results;
}

=item database()

Get/set the database type the search module thinks it should be generating
code for.   Possible answers are mysql, oracle, sqlite, and ansi.

 if ( $search->database eq "mysql" ) {
     # do mysql stuff
 }

=cut

sub database {
    my( $self, $set ) = @_;

    if ( $set ) {
        confess "Invalid/unsupported database \"$set\""
            unless ( $set =~ /^(?:mysql|oracle|ansi|sqlite)$/ );
        $self->{_database} = $set;
    }

    return $self->{_database} if ( $self->{_database} );

    my @dbdrv = DBI->installed_drivers;

    # gross hack
    if ( @dbdrv == 2 && grep(/mysql/i, @dbdrv) ) {
        $self->{_database} = 'mysql';
    }
    elsif ( @dbdrv == 2 && grep(/oracle/i, @dbdrv) ) {
        $self->{_database} = 'oracle';
    }
    else {
        $self->{_database} = 'ansi';
    }
    return $self->{_database};
}

1;

# vim: et ts=4 sw=4 ai smarttab

__END__

=back

=head1 AUTHORS

 Al Tobey <tobert@gmail.com>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2006-2010 by Al Tobey.

This is free software; you can redistribute it and/or modify it under the terms
of the Artistic License 2.0.  (Note that, unlike the Artistic License 1.0,
version 2.0 is GPL compatible by itself, hence there is no benefit to having an
Artistic 2.0 / GPL disjunction.)  See the file LICENSE for details.

=cut


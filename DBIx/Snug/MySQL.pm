package DBIx::Snug::MySQL;

###########################################################################
#                                                                         #
# DBIx::Snug::MySQL                                                       #
# Copyright 2006-2010, Albert P. Tobey <tobert@gmail.com>                 #
# https://github.com/tobert/DBIx-Snug                                     #
#                                                                         #
###########################################################################

use strict;
use warnings;
use base 'DBIx::Snug::DDL';
use Data::Dumper; # I use this a lot when debugging
use Carp;
use DBI;

=head1 NAME

DBIx::Snug::MySQL

=head1 SYNOPSIS

 use DBIx::Snug::MySQL;

=head1 DESCRIPTION

Implements support for MySQL databases.   Everything is taken care of at import.

=cut

our %typemap  = (
    int       => 'int(11)',
    text      => 'text',
    varchar   => 'varchar',
    dttm      => 'int(11)',
    timestamp => 'int(11)',
    bool      => 'int(1)'
);

sub all_tables_ddl {
    my $self = ref($_[0]) ? ref(shift) : shift;
    my @ddls = $self->SUPER::all_tables_ddl;

    unshift @ddls, join( $/,
    "-- MySQL DDL generated by DBIx::Snug",
    "",
    '/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;',
    '/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;',
    '/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;',
    '/*!40101 SET NAMES utf8 */;',
    '/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;',
    '/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;',
    '/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=\'NO_AUTO_VALUE_ON_ZERO\' */;',
    '',
    '');

    push @ddls, join( $/, 
    '',
    '/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;',
    '/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;',
    '/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;',
    '/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;',
    '/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;',
    '/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;',
    '' );

    return wantarray ? @ddls : join( '', @ddls );
}

# limitation: only single-key primary keys can have AUTOINCREMENT (I think)
sub table_ddl {
    my( $self, $table ) = @_;
    my( @keys, @constraints ) = ();

    my $class = $self->find_table_class( $table );
    my $struct = $self->_get_class_struct( $class );

    if ( $class->isa('DBIx::Snug::View') ) {
        return $self->create_view_ddl($class);
    }

    my @pk_cols = $class->primary_key;
    my @columns;

    foreach my $pk ( @pk_cols ) {
        my $type = _get_type( $class, $pk );
        my $seq_col = $class->sequenced_column;
        
        if ( defined $seq_col && $pk eq $seq_col ) {
            $type .= " NOT NULL auto_increment";
        }
        else {
            $type .= $self->default_ddl_frag( $class, $pk );
        }

        push @columns, "    $pk $type";
    }

    foreach my $col ( $class->columns ) {
        my $type = _get_type( $class, $col );
        $type .= $self->default_ddl_frag( $class, $col );
        push @columns, "    $col $type";
    }

    if ( @pk_cols > 0 ) {
        push @keys, "    PRIMARY KEY(" . join(',',@pk_cols) . ")";
    }

    my $fk_idx = 0;
    foreach my $col ( $class->all_columns ) {
        if ( $class->has_foreign_key( $col ) ) {
            my( $fk_tbl, $fk_col, $fk_class ) = $class->foreign_key( $col );
            push @keys, "    KEY " . $fk_tbl . "_index".++$fk_idx." ($col)";
            push @constraints,
                sprintf "    CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s)",
                        $table . "_fk" . ++$fk_idx,
                        $col,
                        $fk_tbl,
                        $fk_col;
        }
    }

    my $ddl = "CREATE TABLE $table ($/";
    $ddl .= join( ",$/", @columns, @keys, @constraints );
    $ddl .= "$/) Type=InnoDB";
}

sub _get_type {
    my( $class, $col ) = @_;

    confess "Bug! Column \"$col\" does not exist in table \"".$class->table.'"'
        unless $class->has_column( $col );

    my $pseudotype = $class->column_pseudotype( $col );

    confess "No type defined for column \"$col\" in class \"$class\""
        unless ( $pseudotype );

    my $size;
    if ( $pseudotype =~ s/\((\d+)\)// ) {
        $size = $1;
    }
    my $type = $typemap{ $pseudotype };
    if ( $size && $type !~ /\(\d+\)$/ ) {
        return "$type($size)";
    }
    else {
        return $type;
    }
}

sub false { 0 }
sub true { 1 }

1;

# vim: et ts=4 sw=4 ai smarttab

__END__

=head1 AUTHORS

 Al Tobey <tobert@gmail.com>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2006-2010 by Al Tobey.

This is free software; you can redistribute it and/or modify it under the terms
of the Artistic License 2.0.  (Note that, unlike the Artistic License 1.0,
version 2.0 is GPL compatible by itself, hence there is no benefit to having an
Artistic 2.0 / GPL disjunction.)  See the file LICENSE for details.

=cut

